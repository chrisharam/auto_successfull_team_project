# canvas_core.py
from __future__ import annotations
from typing import List, Tuple, Optional, Union
from dataclasses import dataclass
import math

from PyQt5.QtCore import Qt, QPoint, QRect
from PyQt5.QtGui import QImage, QPainter, QPen, QBrush, QColor


ColorLike = Union[str, Tuple[int, int, int], QColor]


def _to_qcolor(c: Optional[ColorLike]) -> Optional[QColor]:
    if c is None:
        return None
    if isinstance(c, QColor):
        return QColor(c)
    if isinstance(c, tuple) and len(c) == 3:
        r, g, b = c
        return QColor(int(r), int(g), int(b))
    return QColor(str(c))


# -------------------- 모델: 도형 베이스 및 구현 --------------------

_id_seed = 0
def _next_id() -> int:
    global _id_seed
    _id_seed += 1
    return _id_seed


@dataclass
class Shape:
    """공통 상태: id, 윤곽선 색/두께, (선택)면색"""
    id: int
    stroke: QColor
    width: int
    fill: Optional[QColor] = None  # None이면 채우기 없음

    def draw(self, p: QPainter) -> None:
        raise NotImplementedError

    def contains(self, pt: QPoint) -> bool:
        """면적이 있는 도형(사각형/원)은 내부 포함 여부, 선은 굵기 기준 근접 판정."""
        raise NotImplementedError

    # 채우기 조작
    def set_fill(self, color: Optional[ColorLike]) -> None:
        self.fill = _to_qcolor(color)


@dataclass
class LineShape(Shape):
    p1: QPoint = QPoint()
    p2: QPoint = QPoint()

    def draw(self, p: QPainter) -> None:
        p.setPen(QPen(self.stroke, self.width, Qt.SolidLine, Qt.RoundCap, Qt.RoundJoin))
        p.setBrush(Qt.NoBrush)
        p.drawLine(self.p1, self.p2)

    def contains(self, pt: QPoint) -> bool:
        # 선에는 면이 없어 채우기 의미는 없지만, 선택용으로 근접 판정 제공
        # 선분-점 거리 계산(픽셀)
        x, y = pt.x(), pt.y()
        x1, y1 = self.p1.x(), self.p1.y()
        x2, y2 = self.p2.x(), self.p2.y()
        dx, dy = x2 - x1, y2 - y1
        if dx == 0 and dy == 0:
            # 점과 같은 선
            dist = math.hypot(x - x1, y - y1)
        else:
            t = max(0.0, min(1.0, ((x - x1) * dx + (y - y1) * dy) / float(dx * dx + dy * dy)))
            projx, projy = x1 + t * dx, y1 + t * dy
            dist = math.hypot(x - projx, y - projy)
        # 선 굵기의 절반 + 여유치로 근접 판단
        return dist <= max(3.0, self.width / 2 + 1.5)


@dataclass
class RectShape(Shape):
    rect: QRect = QRect()

    def draw(self, p: QPainter) -> None:
        p.setPen(QPen(self.stroke, self.width, Qt.SolidLine, Qt.RoundCap, Qt.RoundJoin))
        p.setBrush(QBrush(self.fill) if self.fill is not None else Qt.NoBrush)
        p.drawRect(self.rect)

    def contains(self, pt: QPoint) -> bool:
        return self.rect.contains(pt)


@dataclass
class EllipseShape(Shape):
    rect: QRect = QRect()

    def draw(self, p: QPainter) -> None:
        p.setPen(QPen(self.stroke, self.width, Qt.SolidLine, Qt.RoundCap, Qt.RoundJoin))
        p.setBrush(QBrush(self.fill) if self.fill is not None else Qt.NoBrush)
        p.drawEllipse(self.rect)

    def contains(self, pt: QPoint) -> bool:
        # 타원 내부 판정: ((x-cx)/rx)^2 + ((y-cy)/ry)^2 <= 1
        if self.rect.width() == 0 or self.rect.height() == 0:
            return False
        cx = self.rect.x() + self.rect.width() / 2.0
        cy = self.rect.y() + self.rect.height() / 2.0
        rx = self.rect.width() / 2.0
        ry = self.rect.height() / 2.0
        if rx == 0 or ry == 0:
            return False
        nx = (pt.x() - cx) / rx
        ny = (pt.y() - cy) / ry
        return nx * nx + ny * ny <= 1.0


# -------------------- 캔버스 코어(오프스크린 QImage) --------------------

class CanvasCore:
    """
    UI 없이 사용하는 PyQt 오프스크린 캔버스.
    - QImage에 도형들을 레이어 순서대로 렌더링
    - 도형 추가(add_*), 나중에 채우기(set_fill_*), 저장(save_image)
    - 좌표로 히트테스트하여 "그 위치의 맨 위 도형"에 면색 채우기 가능
    """

    def __init__(self, width: int = 800, height: int = 500, bg: ColorLike = "white") -> None:
        self._bg = _to_qcolor(bg) or QColor(Qt.white)
        self.image = QImage(width, height, QImage.Format_RGB32)
        self.shapes: List[Shape] = []
        self._clear_image()  # 배경 칠하기

    # ---------- 도형 추가 ----------
    def add_line(
        self,
        p1: Tuple[int, int],
        p2: Tuple[int, int],
        stroke: ColorLike = "black",
        width: int = 3,
    ) -> int:
        s = LineShape(
            id=_next_id(),
            stroke=_to_qcolor(stroke) or QColor(Qt.black),
            width=max(1, int(width)),
            fill=None,
            p1=QPoint(*p1),
            p2=QPoint(*p2),
        )
        self.shapes.append(s)
        return s.id

    def add_rect(
        self,
        p1: Tuple[int, int],
        p2: Tuple[int, int],
        stroke: ColorLike = "black",
        width: int = 3,
        fill: Optional[ColorLike] = None,  # 초기 채우기 선택 가능(기본 None)
    ) -> int:
        rect = _make_rect(p1, p2)
        s = RectShape(
            id=_next_id(),
            stroke=_to_qcolor(stroke) or QColor(Qt.black),
            width=max(1, int(width)),
            fill=_to_qcolor(fill),
            rect=rect,
        )
        self.shapes.append(s)
        return s.id

    def add_ellipse(
        self,
        p1: Tuple[int, int],
        p2: Tuple[int, int],
        stroke: ColorLike = "black",
        width: int = 3,
        fill: Optional[ColorLike] = None,
    ) -> int:
        rect = _make_rect(p1, p2)
        s = EllipseShape(
            id=_next_id(),
            stroke=_to_qcolor(stroke) or QColor(Qt.black),
            width=max(1, int(width)),
            fill=_to_qcolor(fill),
            rect=rect,
        )
        self.shapes.append(s)
        return s.id

    # ---------- 채우기: 이미 만들어진 도형 ----------
    def set_fill_by_id(self, shape_id: int, color: Optional[ColorLike]) -> bool:
        """지정 ID 도형의 면색을 설정/해제(None)"""
        shp = self._find(shape_id)
        if shp is None:
            return False
        if isinstance(shp, LineShape):
            # 선은 면색 개념이 없지만, API 일관성 유지: 무시 후 True 반환
            shp.set_fill(None)
            return True
        shp.set_fill(color)
        return True

    def set_fill_at_point(self, xy: Tuple[int, int], color: Optional[ColorLike]) -> Optional[int]:
        """
        좌표(x,y)에 '걸리는' 맨 위(topmost) 도형을 찾아 면색 설정.
        반환값: 채우기가 적용된 도형의 id (없으면 None)
        """
        pt = QPoint(*xy)
        # 레이어 상 맨 위가 리스트의 마지막이라고 가정 → 역순 탐색
        for shp in reversed(self.shapes):
            # 선(Line)은 스킵(채우기 대상 아님). 필요하면 contains로 선택만 허용 가능.
            if isinstance(shp, LineShape):
                continue
            if shp.contains(pt):
                shp.set_fill(color)
                return shp.id
        return None

    # ---------- 렌더링/파일 ----------
    def render(self) -> None:
        """현재 도형 상태를 image에 다시 그리기"""
        self._clear_image()
        p = QPainter(self.image)
        p.setRenderHint(QPainter.Antialiasing, True)
        for shp in self.shapes:
            shp.draw(p)
        p.end()

    def save_image(self, path: str) -> bool:
        self.render()
        return self.image.save(path)

    # ---------- 유틸 ----------
    def clear(self) -> None:
        self.shapes.clear()
        self._clear_image()

    def _clear_image(self) -> None:
        self.image.fill(self._bg)

    def _find(self, shape_id: int) -> Optional[Shape]:
        return next((s for s in self.shapes if s.id == shape_id), None)


def _make_rect(p1: Tuple[int, int], p2: Tuple[int, int]) -> QRect:
    x1, y1 = p1
    x2, y2 = p2
    return QRect(min(x1, x2), min(y1, y2), abs(x2 - x1), abs(y2 - y1))

if __name__ == "__main__":
    main()
